// Progress Tracker for HEIC Converter
// Tracks conversion progress with detailed statistics and event handling

class ProgressTracker {
  constructor() {
    this.listeners = new Map();
    this.tasks = new Map(); // Individual task tracking
    this.reset();
  }

  reset() {
    this.stats = {
      totalFiles: 0,
      processedFiles: 0,
      failedFiles: 0,
      cancelledFiles: 0,
      totalBytes: 0,
      processedBytes: 0,
      startTime: null,
      endTime: null,
      averageFileSize: 0,
      estimatedTimeRemaining: null,
      currentThroughput: 0,
    };
    this.tasks.clear();
    this.emitEvent('reset', this.getProgress());
  }

  startTracking(totalFiles, totalBytes) {
    this.stats.totalFiles = totalFiles;
    this.stats.totalBytes = totalBytes;
    this.stats.startTime = Date.now();
    this.stats.averageFileSize = totalFiles > 0 ? totalBytes / totalFiles : 0;
    this.emitEvent('trackingStarted', this.getProgress());
  }

  updateFileProgress(fileSize, progress = 100) {
    const progressBytes = Math.floor((fileSize * progress) / 100);
    this.stats.processedBytes = Math.min(
      this.stats.processedBytes + progressBytes,
      this.stats.totalBytes
    );
    this.updateEstimates();
    this.emitEvent('progressUpdated', this.getProgress());
  }

  completeFile() {
    this.stats.processedFiles++;
    this.updateEstimates();
    this.emitEvent('fileCompleted', this.getProgress());
  }

  failFile() {
    this.stats.failedFiles++;
    this.stats.processedFiles++;
    this.updateEstimates();
    this.emitEvent('fileFailed', this.getProgress());
  }

  cancelFile() {
    this.stats.cancelledFiles++;
    this.updateEstimates();
    this.emitEvent('fileCancelled', this.getProgress());
  }

  updateEstimates() {
    const now = Date.now();
    const elapsed = now - this.stats.startTime;

    if (elapsed > 0 && this.stats.processedBytes > 0) {
      // Calculate throughput in bytes per millisecond
      this.stats.currentThroughput = this.stats.processedBytes / elapsed;

      // Estimate remaining time
      const remainingBytes = this.stats.totalBytes - this.stats.processedBytes;
      if (this.stats.currentThroughput > 0) {
        this.stats.estimatedTimeRemaining =
          remainingBytes / this.stats.currentThroughput;
      }
    }
  }

  finish() {
    this.stats.endTime = Date.now();
    this.emitEvent('trackingFinished', this.getProgress());
  }

  // Task-based tracking methods
  createTask(taskId, metadata = {}) {
    if (!taskId || typeof taskId !== 'string') {
      throw new Error('Task ID must be a non-empty string');
    }
    
    if (this.tasks.has(taskId)) {
      throw new Error(`Task ${taskId} already exists`);
    }

    if (typeof metadata !== 'object' || metadata === null) {
      metadata = {};
    }

    const task = {
      id: taskId,
      status: 'created',
      progress: 0,
      message: 'Task created',
      metadata: {
        fileName: metadata.fileName || 'Unknown file',
        fileSize: metadata.fileSize || 0,
        type: metadata.type || 'single',
        fileCount: metadata.fileCount || 1,
        totalSize: metadata.totalSize || metadata.fileSize || 0,
        ...metadata
      },
      createdAt: Date.now(),
      startedAt: null,
      completedAt: null,
      lastUpdated: Date.now(),
      history: []
    };

    this.tasks.set(taskId, task);
    this.emitEvent('taskCreated', { taskId, task });
    
    return task;
  }

  updateProgress(taskId, progress, message = '', additionalData = {}) {
    if (!taskId || typeof taskId !== 'string') {
      throw new Error('Task ID must be a non-empty string');
    }

    const task = this.tasks.get(taskId);
    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }

    if (typeof progress !== 'number' || isNaN(progress)) {
      throw new Error('Progress must be a number');
    }

    if (progress < 0 || progress > 100) {
      throw new Error('Progress must be between 0 and 100');
    }

    if (task.status === 'completed') {
      console.warn(`Attempting to update progress for completed task ${taskId}`);
      return task;
    }

    if (['failed', 'cancelled'].includes(task.status)) {
      throw new Error(`Cannot update progress for ${task.status} task ${taskId}`);
    }

    if (typeof message !== 'string') {
      message = String(message || '');
    }

    if (typeof additionalData !== 'object' || additionalData === null) {
      additionalData = {};
    }

    // Start task if not already started
    if (task.status === 'created' && progress > 0) {
      task.status = 'in_progress';
      task.startedAt = Date.now();
    }

    // Update progress
    const previousProgress = task.progress;
    task.progress = progress;
    task.message = message;
    task.lastUpdated = Date.now();
    
    // Add to history
    task.history.push({
      timestamp: Date.now(),
      progress,
      message,
      ...additionalData
    });

    // Keep history limited to last 50 entries
    if (task.history.length > 50) {
      task.history.shift();
    }

    this.emitEvent('taskProgressUpdated', { 
      taskId, 
      task, 
      previousProgress,
      progressDelta: progress - previousProgress
    });

    return task;
  }

  completeTask(taskId, result = null) {
    if (!taskId || typeof taskId !== 'string') {
      throw new Error('Task ID must be a non-empty string');
    }

    const task = this.tasks.get(taskId);
    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }

    if (task.status === 'completed') {
      return task;
    }

    task.status = 'completed';
    task.progress = 100;
    task.message = 'Task completed successfully';
    task.completedAt = Date.now();
    task.lastUpdated = Date.now();
    task.result = result;

    task.history.push({
      timestamp: Date.now(),
      progress: 100,
      message: 'Task completed',
      status: 'completed'
    });

    this.emitEvent('taskCompleted', { taskId, task, result });
    
    return task;
  }

  cancelTask(taskId, reason = 'Task cancelled by user') {
    if (!taskId || typeof taskId !== 'string') {
      throw new Error('Task ID must be a non-empty string');
    }

    const task = this.tasks.get(taskId);
    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }

    if (typeof reason !== 'string') {
      reason = String(reason || 'Task cancelled by user');
    }

    if (['completed', 'failed', 'cancelled'].includes(task.status)) {
      return task;
    }

    task.status = 'cancelled';
    task.message = reason;
    task.completedAt = Date.now();
    task.lastUpdated = Date.now();
    task.cancelReason = reason;

    task.history.push({
      timestamp: Date.now(),
      progress: task.progress,
      message: reason,
      status: 'cancelled'
    });

    this.emitEvent('taskCancelled', { taskId, task, reason });
    
    return task;
  }

  failTask(taskId, error, details = {}) {
    if (!taskId || typeof taskId !== 'string') {
      throw new Error('Task ID must be a non-empty string');
    }

    const task = this.tasks.get(taskId);
    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }

    if (!error) {
      error = 'Unknown error';
    } else if (typeof error !== 'string') {
      error = String(error);
    }

    if (typeof details !== 'object' || details === null) {
      details = {};
    }

    if (['completed', 'cancelled'].includes(task.status)) {
      return task;
    }

    task.status = 'failed';
    task.message = `Task failed: ${error}`;
    task.completedAt = Date.now();
    task.lastUpdated = Date.now();
    task.error = error;
    task.errorDetails = details;

    task.history.push({
      timestamp: Date.now(),
      progress: task.progress,
      message: `Failed: ${error}`,
      status: 'failed',
      error,
      ...details
    });

    this.emitEvent('taskFailed', { taskId, task, error, details });
    
    return task;
  }

  getProgress() {
    const fileProgress =
      this.stats.totalFiles > 0
        ? (this.stats.processedFiles / this.stats.totalFiles) * 100
        : 0;

    const byteProgress =
      this.stats.totalBytes > 0
        ? (this.stats.processedBytes / this.stats.totalBytes) * 100
        : 0;

    const elapsedTime = this.stats.startTime
      ? (this.stats.endTime || Date.now()) - this.stats.startTime
      : 0;

    return {
      ...this.stats,
      fileProgressPercent: Math.round(fileProgress * 100) / 100,
      byteProgressPercent: Math.round(byteProgress * 100) / 100,
      elapsedTime,
      isComplete: this.stats.processedFiles >= this.stats.totalFiles,
      throughputBytesPerSecond: this.stats.currentThroughput * 1000,
    };
  }

  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }

  off(event, callback) {
    if (!this.listeners.has(event)) return;

    const callbacks = this.listeners.get(event);
    const index = callbacks.indexOf(callback);
    if (index !== -1) {
      callbacks.splice(index, 1);
    }
  }

  emitEvent(event, data) {
    if (!this.listeners.has(event)) return;

    this.listeners.get(event).forEach((callback) => {
      try {
        callback(data);
      } catch (error) {
        console.error(
          `Error in progress tracker listener for ${event}:`,
          error
        );
      }
    });
  }

  // Helper methods for task and progress information
  getTask(taskId) {
    return this.tasks.get(taskId) || null;
  }

  getTaskProgress(taskId) {
    const task = this.tasks.get(taskId);
    if (!task) return null;

    const elapsedTime = task.startedAt ? Date.now() - task.startedAt : 0;
    const totalTime = task.completedAt ? task.completedAt - task.startedAt : elapsedTime;

    return {
      taskId,
      progress: task.progress,
      status: task.status,
      message: task.message,
      metadata: task.metadata,
      elapsedTime,
      totalTime,
      createdAt: task.createdAt,
      startedAt: task.startedAt,
      completedAt: task.completedAt,
      lastUpdated: task.lastUpdated,
      isComplete: task.status === 'completed',
      isFailed: task.status === 'failed',
      isCancelled: task.status === 'cancelled',
      isActive: task.status === 'in_progress'
    };
  }

  getAllTasks() {
    return Array.from(this.tasks.values()).map(task => ({
      taskId: task.id,
      progress: task.progress,
      status: task.status,
      message: task.message,
      metadata: task.metadata,
      createdAt: task.createdAt,
      startedAt: task.startedAt,
      completedAt: task.completedAt,
      lastUpdated: task.lastUpdated
    }));
  }

  getActiveTasks() {
    return this.getAllTasks().filter(task => task.status === 'in_progress');
  }

  getCompletedTasks() {
    return this.getAllTasks().filter(task => task.status === 'completed');
  }

  getFailedTasks() {
    return this.getAllTasks().filter(task => task.status === 'failed');
  }

  getCancelledTasks() {
    return this.getAllTasks().filter(task => task.status === 'cancelled');
  }

  getOverallProgress() {
    const tasks = Array.from(this.tasks.values());
    if (tasks.length === 0) {
      return {
        totalTasks: 0,
        completedTasks: 0,
        activeTasks: 0,
        failedTasks: 0,
        cancelledTasks: 0,
        overallProgress: 0,
        averageProgress: 0
      };
    }

    const completed = tasks.filter(t => t.status === 'completed').length;
    const active = tasks.filter(t => t.status === 'in_progress').length;
    const failed = tasks.filter(t => t.status === 'failed').length;
    const cancelled = tasks.filter(t => t.status === 'cancelled').length;
    
    const totalProgress = tasks.reduce((sum, task) => sum + task.progress, 0);
    const averageProgress = totalProgress / tasks.length;
    const overallProgress = (completed / tasks.length) * 100;

    return {
      totalTasks: tasks.length,
      completedTasks: completed,
      activeTasks: active,
      failedTasks: failed,
      cancelledTasks: cancelled,
      overallProgress: Math.round(overallProgress * 100) / 100,
      averageProgress: Math.round(averageProgress * 100) / 100,
      ...this.getProgress() // Include legacy stats
    };
  }

  removeTask(taskId) {
    if (!taskId || typeof taskId !== 'string') {
      throw new Error('Task ID must be a non-empty string');
    }

    const task = this.tasks.get(taskId);
    if (task) {
      this.tasks.delete(taskId);
      this.emitEvent('taskRemoved', { taskId, task });
      return true;
    }
    return false;
  }

  taskExists(taskId) {
    return this.tasks.has(taskId);
  }

  getTaskCount() {
    return this.tasks.size;
  }

  isTaskActive(taskId) {
    const task = this.tasks.get(taskId);
    return task ? task.status === 'in_progress' : false;
  }

  isTaskCompleted(taskId) {
    const task = this.tasks.get(taskId);
    return task ? task.status === 'completed' : false;
  }

  getActiveTaskCount() {
    return this.getActiveTasks().length;
  }

  // Bulk operations
  cancelAllTasks(reason = 'All tasks cancelled') {
    const cancelledTasks = [];
    for (const [taskId, task] of this.tasks.entries()) {
      if (task.status === 'in_progress' || task.status === 'created') {
        this.cancelTask(taskId, reason);
        cancelledTasks.push(taskId);
      }
    }
    return cancelledTasks;
  }

  pauseTask(taskId) {
    if (!taskId || typeof taskId !== 'string') {
      throw new Error('Task ID must be a non-empty string');
    }

    const task = this.tasks.get(taskId);
    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }

    if (task.status === 'in_progress') {
      task.status = 'paused';
      task.pausedAt = Date.now();
      task.message = 'Task paused';
      
      task.history.push({
        timestamp: Date.now(),
        progress: task.progress,
        message: 'Task paused',
        status: 'paused'
      });

      this.emitEvent('taskPaused', { taskId, task });
    }
    
    return task;
  }

  resumeTask(taskId) {
    if (!taskId || typeof taskId !== 'string') {
      throw new Error('Task ID must be a non-empty string');
    }

    const task = this.tasks.get(taskId);
    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }

    if (task.status === 'paused') {
      task.status = 'in_progress';
      task.resumedAt = Date.now();
      task.message = 'Task resumed';
      
      // Add pause duration to total pause time
      if (!task.totalPausedTime) task.totalPausedTime = 0;
      if (task.pausedAt) {
        task.totalPausedTime += Date.now() - task.pausedAt;
      }
      
      task.history.push({
        timestamp: Date.now(),
        progress: task.progress,
        message: 'Task resumed',
        status: 'in_progress'
      });

      this.emitEvent('taskResumed', { taskId, task });
    }
    
    return task;
  }

  clearCompletedTasks() {
    const completedTasks = [];
    for (const [taskId, task] of this.tasks.entries()) {
      if (['completed', 'failed', 'cancelled'].includes(task.status)) {
        completedTasks.push({ taskId, task });
        this.tasks.delete(taskId);
      }
    }
    
    if (completedTasks.length > 0) {
      this.emitEvent('tasksCleared', { clearedTasks: completedTasks });
    }
    
    return completedTasks.length;
  }

  getTaskHistory(taskId) {
    const task = this.tasks.get(taskId);
    return task ? task.history : [];
  }

  getTaskStats() {
    const tasks = Array.from(this.tasks.values());
    const now = Date.now();
    
    let totalProcessingTime = 0;
    let completedCount = 0;
    
    tasks.forEach(task => {
      if (task.completedAt && task.startedAt) {
        totalProcessingTime += (task.completedAt - task.startedAt);
        completedCount++;
      }
    });
    
    const averageProcessingTime = completedCount > 0 ? totalProcessingTime / completedCount : 0;
    
    return {
      totalTasks: tasks.length,
      averageProcessingTime,
      oldestTask: tasks.length > 0 ? Math.min(...tasks.map(t => t.createdAt)) : null,
      newestTask: tasks.length > 0 ? Math.max(...tasks.map(t => t.createdAt)) : null,
      tasksPerStatus: {
        created: tasks.filter(t => t.status === 'created').length,
        in_progress: tasks.filter(t => t.status === 'in_progress').length,
        completed: tasks.filter(t => t.status === 'completed').length,
        failed: tasks.filter(t => t.status === 'failed').length,
        cancelled: tasks.filter(t => t.status === 'cancelled').length
      }
    };
  }
}

export default ProgressTracker;
